---
title: java-垃圾回收GC
tags:
  - java
  - gc
  - 拓展阅读
originContent: >-
  是这样的，这个故事从实现一个Array开始说起...


  如果说是一个Int类型的Array，在做删除的时候，我只是需要做index偏移就可以了，因为通过size的index指向了当前Array的最后存储的值得下一个，我只是做size的偏移，就不会再Array中访问到了，也就是做了删除，但是真实的值还是在我的int静态数组中存储中；


  但是，为了通用性，把Int换成了E的泛型哪？会怎么样？


  泛型就不是基础数据类型，而是引用，如果说静态数组中的引用不被删除，那么这个引用指向的数据类型所占用的内存会释放吗？


  答案是：不会！最简单让垃圾回收的方式是，设置当前引用为null。


  这就是我们今天说的垃圾回收GC。


  # 拓展阅读

  - java gc
categories:
  - java
toc: false
date: 2019-01-31 21:16:57
---

是这样的，这个故事从实现一个Array开始说起...

如果说是一个Int类型的Array，在做删除的时候，我只是需要做index偏移就可以了，因为通过size的index指向了当前Array的最后存储的值得下一个，我只是做size的偏移，就不会再Array中访问到了，也就是做了删除，但是真实的值还是在我的int静态数组中存储中；

但是，为了通用性，把Int换成了E的泛型哪？会怎么样？

泛型就不是基础数据类型，而是引用，如果说静态数组中的引用不被删除，那么这个引用指向的数据类型所占用的内存会释放吗？

答案是：不会！最简单让垃圾回收的方式是，设置当前引用为null。
这种对象被称为：loitering objects

这就是我们今天说的垃圾回收GC。

# 拓展阅读
- java gc
- loitering objects